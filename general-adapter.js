/**
 * Type guard function to check if a token is a FontFamilyToken
 *
 * @param token - The token to check
 * @returns True if the token has fontFamily and variableName properties, indicating it's a FontFamilyToken
 */
function isFontFamilyToken(token) {
  return "fontFamily" in token && "variableName" in token;
}
/**
 * Type guard function to check if a token is an EffectToken
 *
 * @param token - The token to check
 * @returns True if the token has effects and variableName properties, indicating it's an EffectToken
 */
function isEffectToken(token) {
  return "effects" in token && "variableName" in token;
}
/**
 * Type guard function to check if a token is a basic Token (color or float)
 *
 * @param token - The token to check
 * @returns True if the token has mode, type, name, and value properties, indicating it's a basic Token
 */
function isColorOrFloatToken(token) {
  return (
    "mode" in token && "type" in token && "name" in token && "value" in token
  );
}

function autoGeneratedFile() {
  return `/* prettier-ignore */
/* eslint-disable */
/* tslint:disable */
/*
Auto-generated by Recursica.
Do NOT edit these files directly\n
For more information about Recursica, go to https://recursica.com
*/
`;
}

function capitalize(str) {
  return str.replace(/-/g, " ").replace(/\b\w/g, (char) => char.toUpperCase());
}

class Tokens {
  constructor(overrides) {
    this.tokens = {};
    this.themes = {};
    this.breakpoints = {};
    this.colors = [];
    this.spacers = [];
    this.borderRadius = [];
    this.uiKit = {};
    this.value = (target, token) => {
      if (typeof token.value === "string") {
        target[token.name] = token.value;
        return true;
      }
      if (typeof token.value === "number") {
        if (token.name.includes("opacity")) {
          target[token.name] = `${token.value / 100}`;
          return true;
        }
        target[token.name] = `${token.value}px`;
        return true;
      }
      if (typeof token.value === "object") {
        target[token.name] = token.value;
        return true;
      }
      return false;
    };
    this.overrides = overrides;
  }
  tokenValue(token, modeName, jsonThemeName) {
    if (token.collection === "Breakpoints") {
      this.value(this.breakpoints, token);
      // Add breakpoints to uiKit with 'breakpoints/' prefix
      const uiKitTarget = {};
      this.value(uiKitTarget, token);
      Object.entries(uiKitTarget).forEach(([key, value]) => {
        // Ensure we only store string values
        if (typeof value === "string") {
          this.uiKit[`breakpoint/${key}`] = value;
        } else if (typeof value === "number") {
          this.uiKit[`breakpoint/${key}`] = `${value.toString()}px`;
        }
      });
    } else if (token.collection === "UI Kit") {
      this.value(this.uiKit, token);
    } else if (token.collection === "Tokens") {
      this.value(this.tokens, token);
    } else {
      if (!jsonThemeName) return;
      if (!this.themes[jsonThemeName]) this.themes[jsonThemeName] = {};
      if (!this.themes[jsonThemeName][modeName])
        this.themes[jsonThemeName][modeName] = {};
      this.value(this.themes[jsonThemeName][modeName], token);
    }
  }
  process(variables, jsonThemeName) {
    // Process tokens collection
    for (const token of Object.values(variables)) {
      if (isFontFamilyToken(token)) {
        if (!jsonThemeName) continue;
        if (!this.tokens[jsonThemeName]) this.tokens[jsonThemeName] = {};
        if (typeof this.tokens[jsonThemeName] !== "object")
          this.tokens[jsonThemeName] = {};
        this.tokens[jsonThemeName][`typography/${token.variableName}`] =
          this.overrides?.fontFamily?.[token.fontFamily] ?? token.fontFamily;
        this.tokens[jsonThemeName][`typography/${token.variableName}-size`] =
          `${token.fontSize.toString()}px`;
        // check if overrides.fontWeight is defined
        if (this.overrides?.fontWeight) {
          const weight = this.overrides.fontWeight.find(
            (weight) =>
              weight.alias === token.fontWeight.alias &&
              weight.fontFamily === token.fontFamily,
          );
          // check if there's a weight that matches the alias and fontFamily
          // if there is, use the value from the overrides
          // if there isn't, use the value from the token
          if (weight) {
            this.tokens[jsonThemeName][
              `typography/${token.variableName}-weight`
            ] = weight.value.toString();
          } else {
            this.tokens[jsonThemeName][
              `typography/${token.variableName}-weight`
            ] = token.fontWeight.value.toString();
          }
        } else {
          this.tokens[jsonThemeName][
            `typography/${token.variableName}-weight`
          ] = token.fontWeight.value.toString();
        }
        if (token.lineHeight.unit === "PERCENT") {
          this.tokens[jsonThemeName][
            `typography/${token.variableName}-line-height`
          ] = `${token.lineHeight.value.toString()}%`;
        } else {
          this.tokens[jsonThemeName][
            `typography/${token.variableName}-line-height`
          ] = "1.2";
        }
        this.tokens[jsonThemeName][
          `typography/${token.variableName}-letter-spacing`
        ] =
          token.letterSpacing.unit === "PIXELS"
            ? `${token.letterSpacing.value.toString()}px`
            : `${token.letterSpacing.value.toString()}%`;
        this.tokens[jsonThemeName][
          `typography/${token.variableName}-text-case`
        ] = token.textCase;
        this.tokens[jsonThemeName][
          `typography/${token.variableName}-text-decoration`
        ] = token.textDecoration;
        continue;
      }
      if (isEffectToken(token)) {
        const effectValue = [];
        token.effects.forEach((effect) => {
          const {
            color: { r, g, b, a },
            offset: { x, y },
            radius,
            spread,
          } = effect;
          effectValue.push(
            `${x.toString()}px ${y.toString()}px ${radius.toString()}px ${spread.toString()}px rgba(${r.toString()}, ${g.toString()}, ${b.toString()}, ${a.toString()})`,
          );
        });
        this.tokens[`effect/${token.variableName}`] = effectValue.join(", ");
        continue;
      }
      if (isColorOrFloatToken(token)) {
        // Handle theme tokens differently
        if (token.collection === "Themes") {
          // For theme tokens, use the mode directly
          const modeName = token.mode.toLowerCase();
          if (!this.themes[modeName]) this.themes[modeName] = {};
          // Store the token value directly by the token name
          this.themes[modeName][token.name] = token.value;
        } else if (token.collection === "UI Kit") {
          // Handle UI Kit tokens
          this.value(this.uiKit, token);
        } else {
          // For regular tokens, process as before
          const modeName = capitalize(token.mode)
            .replace(/[()/]/g, "-")
            .replace(/\s/g, "")
            .replace(/-$/, "");
          // Only create theme entries for actual theme tokens, not regular tokens
          // Regular tokens go into the base tokens collection, not themes
          if (token.type === "color" && !this.colors.includes(token.name)) {
            this.colors.push(token.name);
          }
          if (
            token.name.startsWith("size/spacer/") &&
            !this.spacers.includes(token.name)
          ) {
            this.spacers.push(token.name);
          }
          if (
            token.name.startsWith("size/border-radius/") &&
            !this.borderRadius.includes(token.name)
          ) {
            this.borderRadius.push(token.name);
          }
          this.tokenValue(token, modeName, jsonThemeName);
        }
      } else {
        console.warn(
          `${JSON.stringify(token, null, 2)} could not be processed`,
        );
      }
    }
  }
}

function generateTokensCss(baseTokens, { outputPath }) {
  const tokensCssFilename = "recursica-tokens.css";
  const tokensCssPath = outputPath + "/" + tokensCssFilename;
  // Convert token names to CSS custom property format
  const cssVariables = Object.entries(baseTokens)
    .filter(
      ([_, value]) => typeof value === "string" || typeof value === "number",
    )
    .map(([key, value]) => {
      // Convert kebab-case to CSS custom property format
      const cssVarName = key.replace(/\//g, "-").toLowerCase();
      return `  --${cssVarName}: ${value};`;
    })
    .join("\n");
  const tokensCssContent = `${autoGeneratedFile()}
/* Recursica Design Tokens */
:root {
${cssVariables}
}
`;
  return {
    content: tokensCssContent,
    path: tokensCssPath,
    filename: tokensCssFilename,
  };
}

function generateThemeCss(themes, { outputPath }) {
  const themeFiles = [];
  for (const [themeName, themeTokens] of Object.entries(themes)) {
    // Skip empty themes or non-object themes
    if (
      !themeTokens ||
      typeof themeTokens !== "object" ||
      Array.isArray(themeTokens)
    ) {
      continue;
    }
    const themeCssFilename = `${themeName.toLowerCase()}-theme.css`;
    const themeCssPath = outputPath + "/" + themeCssFilename;
    // Convert theme token names to CSS custom property format
    const cssVariables = Object.entries(themeTokens)
      .map(([key, value]) => {
        const cssVarName = key.replace(/\//g, "-").toLowerCase();
        // Handle different value types
        if (typeof value === "string" || typeof value === "number") {
          return `  --${cssVarName}: ${value};`;
        }
        // Handle object references (like { collection: "Tokens", name: "opacity/solid" })
        if (
          typeof value === "object" &&
          value !== null &&
          "collection" in value &&
          "name" in value
        ) {
          const ref = value;
          const refVarName = ref.name.replace(/\//g, "-").toLowerCase();
          return `  --${cssVarName}: var(--${refVarName});`;
        }
        return null;
      })
      .filter(Boolean)
      .join("\n");
    const themeCssContent = `${autoGeneratedFile()}
/* Recursica ${themeName} Theme */
.${themeName.toLowerCase()}-theme {
${cssVariables}
}
`;
    themeFiles.push({
      content: themeCssContent,
      path: themeCssPath,
      filename: themeCssFilename,
    });
  }
  return themeFiles;
}

function generateUiKitCss(uiKit, themes, { outputPath }) {
  const uiKitCssFilename = "recursica.css";
  const uiKitCssPath = outputPath + "/" + uiKitCssFilename;
  // Generate imports for tokens and all themes
  const imports = [
    '@import "./recursica-tokens.css";',
    ...Object.keys(themes).map(
      (themeName) => `@import "./${themeName.toLowerCase()}-theme.css";`,
    ),
  ].join("\n");
  // Generate UI Kit variables content
  const cssVariables = Object.entries(uiKit)
    .map(([key, value]) => {
      const cssVarName = key.replace(/\//g, "-").toLowerCase();
      // Handle token references (objects with collection and name)
      if (
        typeof value === "object" &&
        value !== null &&
        "collection" in value &&
        "name" in value
      ) {
        const tokenVarName = value.name.replace(/\//g, "-").toLowerCase();
        return `  --${cssVarName}: var(--${tokenVarName});`;
      }
      // Handle string values that might be token references
      if (typeof value === "string" && value.includes("/")) {
        const tokenVarName = value.replace(/\//g, "-").toLowerCase();
        return `  --${cssVarName}: var(--${tokenVarName});`;
      }
      // Handle direct values
      if (typeof value === "string" || typeof value === "number") {
        return `  --${cssVarName}: ${value};`;
      }
      // Skip other types
      return null;
    })
    .filter(Boolean)
    .join("\n");
  const uiKitCssContent = `${autoGeneratedFile()}
/* Recursica UI Kit */
${imports}

.recursica {
${cssVariables}
}
`;
  return {
    content: uiKitCssContent,
    path: uiKitCssPath,
    filename: uiKitCssFilename,
  };
}

function generateRecursicaObject(tokens, uiKit, themes, { outputPath }) {
  const recursicaObjectFilename = "recursica.js";
  const recursicaObjectPath = outputPath + "/" + recursicaObjectFilename;
  // Generate tokens object
  const tokensEntries = Object.entries(tokens)
    .filter(
      ([_, value]) => typeof value === "string" || typeof value === "number",
    )
    .map(
      ([key, value]) =>
        `  "${key}": "var(--${key.replace(/\//g, "-").toLowerCase()})"`,
    )
    .join(",\n");
  // Generate UI Kit object
  const uiKitEntries = Object.entries(uiKit)
    .map(([key, value]) => {
      const cssVarName = key.replace(/\//g, "-").toLowerCase();
      // Handle token references (objects with collection and name)
      if (
        typeof value === "object" &&
        value !== null &&
        "collection" in value &&
        "name" in value
      ) {
        const tokenVarName = value.name.replace(/\//g, "-").toLowerCase();
        return `  "${key}": "var(--${tokenVarName})"`;
      }
      // Handle string values that might be token references
      if (typeof value === "string" && value.includes("/")) {
        const tokenVarName = value.replace(/\//g, "-").toLowerCase();
        return `  "${key}": "var(--${tokenVarName})"`;
      }
      // Handle direct values
      if (typeof value === "string" || typeof value === "number") {
        return `  "${key}": "var(--${cssVarName})"`;
      }
      return null;
    })
    .filter(Boolean)
    .join(",\n");
  // Generate themes object
  const themesEntries = Object.entries(themes)
    .map(([themeName, themeTokens]) => {
      const themeEntries = Object.entries(themeTokens)
        .map(([key, value]) => {
          const cssVarName = key.replace(/\//g, "-").toLowerCase();
          // Handle different value types
          if (typeof value === "string" || typeof value === "number") {
            return `    "${key}": "var(--${cssVarName})"`;
          }
          // Handle object references
          if (
            typeof value === "object" &&
            value !== null &&
            "collection" in value &&
            "name" in value
          ) {
            const ref = value;
            const refVarName = ref.name.replace(/\//g, "-").toLowerCase();
            return `    "${key}": "var(--${refVarName})"`;
          }
          return null;
        })
        .filter(Boolean)
        .join(",\n");
      return `  "${themeName}": {\n${themeEntries}\n  }`;
    })
    .join(",\n");
  const recursicaObjectContent = `${autoGeneratedFile()}
/**
 * Recursica Design System Lookup Object
 * 
 * This object provides type-safe access to all CSS custom properties
 * generated from your design tokens. Use it to style components programmatically.
 * 
 * Example usage:
 * style={{ backgroundColor: recursica.tokens["color/primary/500"] }}
 * style={{ padding: recursica.uiKit["button/size/padding"] }}
 * style={{ color: recursica.themes.light["text/primary"] }}
 */

export const recursica = {
  tokens: {
${tokensEntries}
  },
  uiKit: {
${uiKitEntries}
  },
  themes: {
${themesEntries}
  }
};

export default recursica;
`;
  return {
    content: recursicaObjectContent,
    path: recursicaObjectPath,
    filename: recursicaObjectFilename,
  };
}

function generateRecursicaTypes(tokens, uiKit, themes, { outputPath }) {
  const recursicaTypesFilename = "recursica.d.ts";
  const recursicaTypesPath = outputPath + "/" + recursicaTypesFilename;
  // Generate token type keys
  const tokenKeys = Object.keys(tokens)
    .filter((key) => {
      const value = tokens[key];
      return typeof value === "string" || typeof value === "number";
    })
    .map((key) => `  "${key}"`)
    .join(" |\n");
  // Generate UI Kit type keys
  const uiKitKeys = Object.keys(uiKit)
    .map((key) => `  "${key}"`)
    .join(" |\n");
  // Generate theme type keys
  const themeKeys = Object.keys(themes)
    .map((key) => `  "${key}"`)
    .join(" |\n");
  // Generate individual theme type keys
  const individualThemeTypes = Object.entries(themes)
    .map(([themeName, themeTokens]) => {
      const themeTokenKeys = Object.keys(themeTokens)
        .map((key) => `    "${key}"`)
        .join(" |\n");
      return `export type RecursicaTheme${themeName.charAt(0).toUpperCase() + themeName.slice(1)} = 
${themeTokenKeys};`;
    })
    .join("\n\n");
  const recursicaTypesContent = `${autoGeneratedFile()}
/**
 * Recursica Design System Type Definitions
 * 
 * Type-safe interfaces for accessing design tokens, UI Kit variables, and themes.
 * These types are automatically generated from your design tokens.
 */

// Token type definitions
export type RecursicaToken = 
${tokenKeys};

// UI Kit type definitions  
export type RecursicaUiKit = 
${uiKitKeys};

// Theme type definitions
export type RecursicaTheme = 
${themeKeys};

// Individual theme type definitions
${individualThemeTypes}

// Main recursica object type
export interface Recursica {
  tokens: Record<RecursicaToken, string>;
  uiKit: Record<RecursicaUiKit, string>;
  themes: {
    [K in RecursicaTheme]: K extends keyof RecursicaThemeMap 
      ? RecursicaThemeMap[K] 
      : Record<string, string>;
  };
}

// Theme map for individual theme types
export interface RecursicaThemeMap {
${Object.entries(themes)
  .map(
    ([themeName]) =>
      `  "${themeName}": Record<RecursicaTheme${themeName.charAt(0).toUpperCase() + themeName.slice(1)}, string>;`,
  )
  .join("\n")}
}

// CSS Variable type (for direct CSS variable access)
export type RecursicaCSSVariable = \`var(--\${string})\`;
`;
  return {
    content: recursicaTypesContent,
    path: recursicaTypesPath,
    filename: recursicaTypesFilename,
  };
}

function generateIcons(icons, srcPath, config) {
  let iconsPath;
  if (!config?.output) {
    iconsPath = srcPath + "/components" + "/Icons";
  } else {
    iconsPath = srcPath + "/" + config.output;
  }
  const svgPath = iconsPath + "/Svg";
  const exportedIcons = [];
  // Generate svg files
  for (const [rawIconName, iconPath] of Object.entries(icons)) {
    const [iconName, variant] = rawIconName.split("[");
    let cleanIconName = iconName.replaceAll("-", "_");
    // check if the iconName is in the names array, if not, skip
    if (config?.include) {
      if (!config?.include?.names?.includes(cleanIconName)) {
        continue;
      }
    }
    // detect if the iconName starts with a number, if so, add an underscore to the beginning
    if (cleanIconName.match(/^\d/)) {
      cleanIconName = `_${cleanIconName}`;
    }
    const cleanVariant = variant.replace("]", "").replace("Style=", "");
    const codedVariant = cleanVariant.replaceAll(" ", "_");
    // check if the codedVariant is in the variants array, if not, skip
    if (config?.include) {
      if (!config?.include?.variants?.includes(codedVariant)) {
        continue;
      }
    }
    const finalIconName = `${cleanIconName}_${codedVariant}`;
    exportedIcons.push({
      content: iconPath
        .replaceAll('fill="black"', "")
        .replaceAll('fill="none"', ""),
      path: `${svgPath}/${finalIconName}.svg`,
      filename: `${finalIconName}`,
    });
  }
  // Generate icon exports file
  const exportsPath = iconsPath + "/icon_exports.ts";
  let exportsContent = `${autoGeneratedFile()}
/// <reference types="vite-plugin-svgr/client" />\n`;
  for (const icon of exportedIcons) {
    exportsContent += `import ${icon.filename} from './Svg/${icon.filename}.svg?react';\n`;
    exportsContent += `export { ${icon.filename} };\n`;
  }
  // Generate icon map file
  const mapPath = iconsPath + "/icon_resource_map.ts";
  let mapContent = `${autoGeneratedFile()}\nimport * as IconExports from './icon_exports';\n\n`;
  mapContent += "export const IconResourceMap = {";
  mapContent += exportedIcons
    .map((icon) => `\n\t'${icon.filename}': IconExports.${icon.filename},`)
    .join("");
  mapContent += "\n};\n";
  return {
    exportedIcons,
    iconExports: {
      content: exportsContent,
      path: exportsPath,
      filename: "icon_exports.ts",
    },
    iconResourceMap: {
      content: mapContent,
      path: mapPath,
      filename: "icon_resource_map.ts",
    },
  };
}

function generatePrettierignore() {
  return {
    filename: ".prettierignore",
    path: ".prettierignore",
    content: `recursica/
recursica.json
recursica-bundle.json
recursica-icons.json
icon_exports.ts
icon_resource_map.ts`,
  };
}

function runAdapter({
  rootPath,
  overrides,
  srcPath,
  project,
  icons,
  iconsConfig,
  tokens,
}) {
  const outputPath = srcPath + "/recursica";
  const tokensCss = generateTokensCss(tokens.tokens, {
    outputPath,
  });
  const themeCssFiles = generateThemeCss(tokens.themes, {
    outputPath,
  });
  const uiKitCss = generateUiKitCss(tokens.uiKit, tokens.themes, {
    outputPath,
  });
  const recursicaObject = generateRecursicaObject(
    tokens.tokens,
    tokens.uiKit,
    tokens.themes,
    {
      outputPath,
    },
  );
  const recursicaTypes = generateRecursicaTypes(
    tokens.tokens,
    tokens.uiKit,
    tokens.themes,
    {
      outputPath,
    },
  );
  const prettierignore = generatePrettierignore();
  const files = [
    tokensCss,
    uiKitCss,
    recursicaObject,
    recursicaTypes,
    prettierignore,
  ];
  // Add theme CSS files
  files.push(...themeCssFiles);
  // Add icon files if icons are provided
  if (icons && Object.keys(icons).length > 0) {
    const iconsObject = generateIcons(icons, srcPath, iconsConfig);
    files.push(iconsObject.iconExports);
    files.push(iconsObject.iconResourceMap);
    files.push(...iconsObject.exportedIcons);
  }
  return files;
}

/**
 * Processes JSON content and creates process instance
 * This is shared logic between CLI and WebWorker
 */
function processJsonContent(jsonFileContent, { overrides }) {
  const jsonContent = JSON.parse(jsonFileContent);
  const tokens = new Tokens(overrides);
  tokens.process(jsonContent.tokens);
  for (const theme of Object.keys(jsonContent.themes)) {
    tokens.process(jsonContent.themes[theme], theme);
  }
  tokens.process(jsonContent.uiKit);
  return tokens;
}
/**
 * Processes icons JSON content and returns icons object
 * This is shared logic between CLI and WebWorker
 */
function processIcons(iconsJsonContent) {
  const icons = {};
  const iconsJsonParsed = JSON.parse(iconsJsonContent);
  for (const [iconName, iconPath] of Object.entries(iconsJsonParsed)) {
    icons[iconName] = iconPath;
  }
  return icons;
}
/**
 * Core adapter processing logic shared between CLI and WebWorker
 * This function handles the main processing workflow
 */
function processAdapter({
  rootPath,
  bundledJsonContent,
  project,
  overrides,
  srcPath,
  iconsJsonContent,
  iconsConfig,
}) {
  let icons = {};
  // Process icons if provided
  if (iconsJsonContent) {
    icons = processIcons(iconsJsonContent);
  }
  if (!bundledJsonContent) {
    throw new Error("bundledJson content not found");
  }
  // Process the main JSON content
  const tokens = processJsonContent(bundledJsonContent, {
    overrides,
  });
  // Run the adapter
  const result = runAdapter({
    rootPath,
    overrides,
    srcPath,
    icons,
    tokens,
    project,
    iconsConfig,
  });
  return result;
}

// 1. Listen for a message from the main application thread
// You can use self.addEventListener or the shorter self.onmessage
self.onmessage = (event) => {
  // Run the script
  const params = event.data;
  try {
    const { bundledJson, srcPath, project, overrides, iconsConfig, rootPath } =
      params;
    if (!bundledJson) throw new Error("bundledJson not found");
    // Use shared processing logic
    const files = processAdapter({
      bundledJsonContent: params.bundledJson,
      project,
      overrides,
      srcPath,
      rootPath,
      iconsJsonContent: params.iconsJson,
      iconsConfig,
    });
    // 3. Send the response back to the main thread
    console.log("...Worker sending response back:", files);
    self.postMessage(files);
  } catch (error) {
    console.error("Error generating theme:", error);
  }
};
