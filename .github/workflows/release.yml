# Unified Release Workflow
#
# This workflow handles releases for ALL packages and apps in the monorepo using Changesets.
# It replaces the previous separate release-plugin.yml and release-plugin-test.yml workflows.
#
# How it works:
# 1. Triggers on changes to .changeset/ files, apps/, packages/, or package files
# 2. Uses Changesets to detect which packages have version changes
# 3. Runs `changeset publish` which:
#    - Bumps version numbers in package.json files
#    - Runs each package's `prepublishOnly` script with appropriate environment variables
#    - Publishes packages to npm in dependency order
# 4. Conditionally creates GitHub releases and deploys only for affected packages
#
# Environment Variables:
# - Production variables (VITE_*) are used by the main figma plugin
# - Test variables (RECURSICA_API_TEST, PLUGIN_PHRASE_TEST) are used by the test plugin
# - Each package's prepublish script handles its own environment variable mapping
#
# Smart Package Detection:
# - GitHub releases are automatically created by Changesets for all packages with changes
# - Only deploys to production when the main figma plugin is released
# - Test plugin releases are handled automatically by Changesets without additional steps

name: Release

on:
  push:
    branches:
      - main
    paths:
      - ".changeset/**"
      - "apps/**"
      - "packages/**"
      - "package.json"
      - "package-lock.json"

jobs:
  release:
    name: Release
    runs-on: ubuntu-latest
    permissions:
      contents: write # To create releases and tags
      pull-requests: write # To create pull requests
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          registry-url: "https://registry.npmjs.org"

      - name: Install dependencies
        run: npm ci
        env:
          HUSKY: 0

      # Caches the Turborepo build artifacts stored in the `.turbo` directory.
      # This avoids re-running tasks on unchanged code, speeding up the build.
      # - name: Cache Turborepo
      #   uses: actions/cache@v4
      #   with:
      #     path: .turbo
      #     key: ${{ runner.os }}-turbo-${{ hashFiles('**/package-lock.json') }}
      #     restore-keys: |
      #       ${{ runner.os }}-turbo-

      # Build all packages before publishing
      # This ensures all dist/ folders are up-to-date and prevents releases if builds fail
      - name: Build Everything
        run: |
          echo "üîç DEBUG: GitHub secrets and variables values (raw):"
          echo "  RECURSICA_API: '${{ vars.RECURSICA_API }}'"
          echo "  PLUGIN_PHRASE: '${{ secrets.PLUGIN_PHRASE }}'"
          echo "  RECURSICA_API_TEST: '${{ vars.RECURSICA_API_TEST }}'"
          echo "  PLUGIN_PHRASE_TEST: '${{ secrets.PLUGIN_PHRASE_TEST }}'"
          echo ""
          echo "üîç DEBUG: GitHub secrets lengths:"
          echo "  RECURSICA_API length: ${#RECURSICA_API}"
          echo "  PLUGIN_PHRASE length: ${#PLUGIN_PHRASE}"
          echo "  RECURSICA_API_TEST length: ${#RECURSICA_API_TEST}"
          echo "  PLUGIN_PHRASE_TEST length: ${#PLUGIN_PHRASE_TEST}"
          echo ""
          echo "üîç DEBUG: GitHub secrets/variables lengths (alternative method):"
          echo "  RECURSICA_API length: $(echo -n '${{ vars.RECURSICA_API }}' | wc -c)"
          echo "  PLUGIN_PHRASE length: $(echo -n '${{ secrets.PLUGIN_PHRASE }}' | wc -c)"
          echo "  RECURSICA_API_TEST length: $(echo -n '${{ vars.RECURSICA_API_TEST }}' | wc -c)"
          echo "  PLUGIN_PHRASE_TEST length: $(echo -n '${{ secrets.PLUGIN_PHRASE_TEST }}' | wc -c)"
          echo ""
          echo "üîç DEBUG: Environment variables being set in workflow:"
          echo "  VITE_RECURSICA_API_URL: '${{ vars.RECURSICA_API }}'"
          echo "  VITE_RECURSICA_UI_URL: '${{ vars.RECURSICA_API }}'"
          echo "  VITE_PLUGIN_PHRASE: '${{ secrets.PLUGIN_PHRASE }}'"
          echo "  RECURSICA_API_TEST: '${{ vars.RECURSICA_API_TEST }}'"
          echo "  PLUGIN_PHRASE_TEST: '${{ secrets.PLUGIN_PHRASE_TEST }}'"
          echo ""
          echo "üîç DEBUG: Environment variables from env section:"
          echo "  VITE_RECURSICA_API_URL: '$VITE_RECURSICA_API_URL'"
          echo "  VITE_RECURSICA_UI_URL: '$VITE_RECURSICA_UI_URL'"
          echo "  VITE_PLUGIN_PHRASE: '$VITE_PLUGIN_PHRASE'"
          echo "  RECURSICA_API_TEST: '$RECURSICA_API_TEST'"
          echo "  PLUGIN_PHRASE_TEST: '$PLUGIN_PHRASE_TEST'"
          echo ""
          # Export environment variables to ensure they're available to all child processes
          export VITE_RECURSICA_API_URL="${{ vars.RECURSICA_API }}"
          export VITE_RECURSICA_UI_URL="${{ vars.RECURSICA_API }}"
          export VITE_PLUGIN_PHRASE="${{ secrets.PLUGIN_PHRASE }}"
          export RECURSICA_API_TEST="${{ vars.RECURSICA_API_TEST }}"
          export PLUGIN_PHRASE_TEST="${{ secrets.PLUGIN_PHRASE_TEST }}"
          echo ""
          echo "üîç DEBUG: Exported environment variables:"
          echo "  VITE_RECURSICA_API_URL: '$VITE_RECURSICA_API_URL'"
          echo "  VITE_RECURSICA_UI_URL: '$VITE_RECURSICA_UI_URL'"
          echo "  VITE_PLUGIN_PHRASE: '$VITE_PLUGIN_PHRASE'"
          echo "  RECURSICA_API_TEST: '$RECURSICA_API_TEST'"
          echo "  PLUGIN_PHRASE_TEST: '$PLUGIN_PHRASE_TEST'"
          echo ""
          echo "üîç DEBUG: All environment variables containing VITE_, RECURSICA_, or PLUGIN_:"
          env | grep -E "(VITE_|RECURSICA_|PLUGIN_)" | sort
          echo ""
          echo "üîç DEBUG: Starting build process..."
          npm run build
          echo ""
          echo "üîç DEBUG: Environment variables after build:"
          echo "  VITE_RECURSICA_API_URL: '$VITE_RECURSICA_API_URL'"
          echo "  VITE_RECURSICA_UI_URL: '$VITE_RECURSICA_UI_URL'"
          echo "  VITE_PLUGIN_PHRASE: '$VITE_PLUGIN_PHRASE'"
          echo "  RECURSICA_API_TEST: '$RECURSICA_API_TEST'"
          echo "  PLUGIN_PHRASE_TEST: '$PLUGIN_PHRASE_TEST'"
          echo ""
          echo "üîç DEBUG: All environment variables containing VITE_, RECURSICA_, or PLUGIN_ after build:"
          env | grep -E "(VITE_|RECURSICA_|PLUGIN_)" | sort
        env:
          # Production environment variables (for main plugin)
          VITE_RECURSICA_API_URL: ${{ vars.RECURSICA_API }}
          VITE_RECURSICA_UI_URL: ${{ vars.RECURSICA_API }}
          VITE_PLUGIN_PHRASE: ${{ secrets.PLUGIN_PHRASE }}
          # Test environment variables (for test plugin)
          RECURSICA_API_TEST: ${{ vars.RECURSICA_API_TEST }}
          PLUGIN_PHRASE_TEST: ${{ secrets.PLUGIN_PHRASE_TEST }}

      # Changesets Action - The Core of Our Release System
      #
      # This action has two modes:
      # 1. If changesets are present, it creates a "Version Packages" pull request.
      # 2. When the "Version Packages" PR is merged, it runs the `publish` command.
      #
      # The `publish` command executes `npm run release` which runs `changeset publish --access public`.
      # This command:
      # - Bumps version numbers in package.json files based on changeset files
      # - Runs each package's `prepublishOnly` script in dependency order (if they have one)
      # - Publishes packages to npm with proper authentication
      # - Creates GitHub releases automatically with changelog and links to PRs
      # - Handles all dependency relationships automatically
      #
      # Note: All packages are built in the previous "Build Everything" step, so this step focuses on
      # versioning, publishing, and creating GitHub releases.
      #
      # Note: Figma plugins have `publishConfig.access: "restricted"` to prevent npm publishing
      # but still allow Changesets to handle versioning and GitHub releases
      - name: Create Release Pull Request or Publish to GitHub Releases
        id: changesets
        uses: changesets/action@v1
        with:
          publish: npm run release
        env:
          GITHUB_TOKEN: ${{ secrets.RELEASE_PAT }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

      # Publish packages (create zip files for figma plugins)
      # Note: All packages are already built, so this step only creates zip files
      - name: Publish Packages
        if: steps.changesets.outputs.published == 'true'
        id: publish-packages
        run: node scripts/publish.mjs '${{ steps.changesets.outputs.publishedPackages }}'

      # Create and upload release assets for published packages
      - name: Create and Upload Release Assets
        if: steps.publish-packages.outputs.HAS_PACKAGES_TO_PUBLISH == 'true'
        id: upload-assets
        run: node scripts/upload-release-assets.mjs '${{ steps.publish-packages.outputs.PUBLISH_RESULTS }}'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Deploy to production when Version Packages PR is merged
      # This step only runs when the main figma plugin was successfully uploaded as a release asset.
      # It deploys the built plugin files to the production server.
      - name: Deploy Figma Plugin to Production
        if: steps.publish-packages.outputs.HAS_PACKAGES_TO_PUBLISH == 'true' && steps.upload-assets.outputs.FIGMA_PLUGIN_PROCESSED == 'true'
        uses: ./.github/actions/deploy-to-server
        with:
          token: ${{ secrets.DISPATCH_TOKEN }}
          target_repository: ${{ github.repository_owner }}/recursica-server
          commit_sha: ${{ github.sha }}
          source_repo: ${{ github.repository }}
          environment: "prod"
          files_path: "apps/figma-plugin/dist/**/*"
          event_type: "trigger-server-deploy"
          plugin_version: ${{ steps.upload-assets.outputs.FIGMA_PLUGIN_VERSION }}
