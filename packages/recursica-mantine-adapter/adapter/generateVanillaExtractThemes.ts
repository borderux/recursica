import type {
  Themes,
  ExportingProps,
  ValueToken,
  ContractTokens,
  ThemeTokens,
  ExportingResult,
} from "../types";
import { autoGeneratedFile } from "../utils/autoGeneratedFile";
import { capitalize } from "../utils/capitalize";
interface ThemeContent {
  name: string;
  content: string;
}

export function parseValue(
  value: ValueToken | string,
  recursicaTokens: string,
) {
  if (typeof value === "object") {
    if (value.collection === "Tokens") {
      return `${recursicaTokens}["${value.name}"]`;
    }
    if (value.collection === "Themes") {
      return `themeVars["${value.name}"]`;
    }
  } else if (!isNaN(Number(value))) {
    return `"${value}"`;
  }
  return `"${value.toString()}"`;
}

function generateTypeDefinitions(
  themeDef: Record<string, Record<string, string>>,
): string {
  // Extract all unique theme modes from themeDef
  const allThemeModes = new Set<string>();
  Object.values(themeDef).forEach((themeVariants) => {
    Object.keys(themeVariants).forEach((mode) => {
      allThemeModes.add(mode);
    });
  });

  // Generate the ThemeVariant interface dynamically
  const themeVariantProperties = Array.from(allThemeModes)
    .sort() // Sort for consistent output
    .map((mode) => `  ${mode}: string;`)
    .join("\n");

  return `${autoGeneratedFile()}
import { THEMES } from "./RecursicaThemes";

export interface ThemeVariant {
${themeVariantProperties}
}

// TypeScript will automatically infer this as a union of literal types
export type ThemeType = typeof THEMES[keyof typeof THEMES];

export type ThemeDictionary = Record<ThemeType, ThemeVariant>;
`;
}

export interface VanillaExtractThemesOutput {
  themesFileContent: ExportingResult;
  vanillaExtractThemes: ExportingResult[];
  availableThemes: ExportingResult;
  themeContract: ExportingResult;
  contractTokens: ContractTokens;
  typeDefinitions: ExportingResult;
}

export function generateVanillaExtractThemes(
  tokens: ThemeTokens,
  themes: Themes,
  recursicaTokensFilename: string,
  { outputPath, project }: ExportingProps,
): VanillaExtractThemesOutput {
  const themesContent: ThemeContent[] = [];
  // Contract tokens
  const projectName =
    typeof project === "string" ? project : (project.name ?? "Recursica");
  const themeContractFilename = `Recursica${projectName}ContractTheme.css`;
  const contractThemeOutputPath =
    outputPath + "/" + `${themeContractFilename}.ts`;
  const contractTokens: ContractTokens = {};

  const themeDef: Record<string, Record<string, string>> = {};

  for (const [rawThemeName, currentTheme] of Object.entries(themes)) {
    for (const [key, theme] of Object.entries(currentTheme)) {
      const currentThemeName = capitalize(rawThemeName);
      const recursicaTokens = `Recursica${projectName}Tokens`;

      const themeKey = key.replace(/-([a-z])/g, (_, letter: string) =>
        letter.toUpperCase(),
      );

      const themeName = `${currentThemeName}${themeKey}Theme`;

      if (!themeDef[currentThemeName]) {
        themeDef[currentThemeName] = {};
      }
      themeDef[currentThemeName][themeKey] = themeName;

      const generatedThemeContent = `${autoGeneratedFile()}
import { createTheme } from '@vanilla-extract/css';

import { themeVars } from './${themeContractFilename.replace(".ts", "")}'
import { ${recursicaTokens} } from './${recursicaTokensFilename.replace(".ts", "")}'

export const ${themeName} = createTheme(themeVars,{
  ${Object.entries(theme)
    .map(([key, value]) => {
      contractTokens[key] = null;
      return `'${key}': ${parseValue(value as ValueToken | string, recursicaTokens)}`;
    })
    .join(",\n\t")},
  ${Object.entries(tokens?.[rawThemeName] ?? {})
    .map(([key, value]) => {
      contractTokens[key] = null;
      return `'${key}': ${parseValue(value as ValueToken | string, recursicaTokens)}`;
    })
    .join(",\n\t")}
})`;

      themesContent.push({
        name: themeName,
        content: generatedThemeContent,
      });
    }
  }

  let themesFileContent = autoGeneratedFile();
  const vanillaExtractThemes: ExportingResult[] = [];
  for (const theme of themesContent) {
    const themeName = `Recursica${projectName}${theme.name}`;
    const autoGeneratedThemeFilename = `${themeName}.css.ts`;
    const themeFilePath = outputPath + "/" + autoGeneratedThemeFilename;
    vanillaExtractThemes.push({
      content: theme.content,
      path: themeFilePath,
      filename: autoGeneratedThemeFilename,
    });
    // generate a theme.css.ts where we import all the themes using just 1 variables (1 export)
    themesFileContent += `export { ${theme.name} } from './${autoGeneratedThemeFilename.replace(".ts", "")}';\n`;
    themesFileContent += `import { ${theme.name} } from './${autoGeneratedThemeFilename.replace(".ts", "")}';\n`;
  }
  themesFileContent += `\nexport const Themes = {
  ${Object.entries(themeDef)
    .map(
      ([key, value]) =>
        `'${key}': {
    ${Object.entries(value)
      .map(([key, value]) => `'${key}': ${value}`)
      .join(",\n\t\t")}`,
    )
    .join("\n\t},\n\t")}
  }
}`;
  // create the themes.ts file
  const availableThemesContent = `${autoGeneratedFile()}
export const AvailableThemes = [${themesContent.map((theme) => `"${theme.name}"`).join(", ")}] as const;
export type AvailableThemesType = (typeof AvailableThemes)[number];
`;
  const availableThemesPath = outputPath + "/types.ts";

  const themeContractContent = `${autoGeneratedFile()}
import { createThemeContract } from '@vanilla-extract/css';

export const themeVars = createThemeContract(${JSON.stringify(contractTokens, null, 2)});
`;

  const themesFilename = `Recursica${projectName}Themes.css.ts`;
  const themesFilePath = outputPath + "/" + themesFilename;

  // Generate type definitions in types.d.ts
  const typeDefinitionsContent = generateTypeDefinitions(themeDef);
  const typesPath = outputPath + "/types.d.ts";
  return {
    typeDefinitions: {
      content: typeDefinitionsContent,
      path: typesPath,
      filename: "types.d.ts",
    },
    themesFileContent: {
      content: themesFileContent,
      path: themesFilePath,
      filename: themesFilename,
    },
    availableThemes: {
      content: availableThemesContent,
      path: availableThemesPath,
      filename: "types.ts",
    },
    vanillaExtractThemes,
    themeContract: {
      content: themeContractContent,
      path: contractThemeOutputPath,
      filename: themeContractFilename,
    },
    contractTokens,
  };
}
