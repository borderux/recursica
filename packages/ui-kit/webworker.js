/**
 * Type guard function to check if a token is a FontFamilyToken
 *
 * @param token - The token to check
 * @returns True if the token has fontFamily and variableName properties, indicating it's a FontFamilyToken
 */
function isFontFamilyToken(token) {
  return "fontFamily" in token && "variableName" in token;
}
/**
 * Type guard function to check if a token is an EffectToken
 *
 * @param token - The token to check
 * @returns True if the token has effects and variableName properties, indicating it's an EffectToken
 */
function isEffectToken(token) {
  return "effects" in token && "variableName" in token;
}
/**
 * Type guard function to check if a token is a basic Token (color or float)
 *
 * @param token - The token to check
 * @returns True if the token has mode, type, name, and value properties, indicating it's a basic Token
 */
function isColorOrFloatToken(token) {
  return (
    "mode" in token && "type" in token && "name" in token && "value" in token
  );
}

function autoGeneratedFile() {
  return `/* prettier-ignore */
/* eslint-disable */
/* tslint:disable */
/*
Auto-generated by Recursica.
Do NOT edit these files directly\n
For more information about Recursica, go to https://recursica.com
*/
`;
}

function capitalize(str) {
  return str.replace(/-/g, " ").replace(/\b\w/g, (char) => char.toUpperCase());
}

class ProcessTokens {
  constructor(overrides) {
    this.tokens = {};
    this.themes = {};
    this.breakpoints = {};
    this.colors = [];
    this.spacers = [];
    this.borderRadius = [];
    this.uiKit = {};
    this.processValue = (target, token) => {
      if (typeof token.value === "string") {
        target[token.name] = token.value;
        return true;
      }
      if (typeof token.value === "number") {
        target[token.name] = `${token.value}px`;
        return true;
      }
      if (typeof token.value === "object") {
        target[token.name] = token.value;
        return true;
      }
      return false;
    };
    this.overrides = overrides;
  }
  processTokenValue(token, modeName, jsonThemeName) {
    if (token.collection === "Breakpoints") {
      this.processValue(this.breakpoints, token);
      // Add breakpoints to uiKit with 'breakpoints/' prefix
      const uiKitTarget = {};
      this.processValue(uiKitTarget, token);
      Object.entries(uiKitTarget).forEach(([key, value]) => {
        // Ensure we only store string values
        if (typeof value === "string") {
          this.uiKit[`breakpoint/${key}`] = value;
        } else if (typeof value === "number") {
          this.uiKit[`breakpoint/${key}`] = `${value.toString()}px`;
        }
      });
    } else if (token.collection === "UI Kit") {
      this.processValue(this.uiKit, token);
    } else if (token.collection === "Tokens") {
      this.processValue(this.tokens, token);
    } else {
      if (!jsonThemeName) return;
      if (!this.themes[jsonThemeName]) this.themes[jsonThemeName] = {};
      if (!this.themes[jsonThemeName][modeName])
        this.themes[jsonThemeName][modeName] = {};
      this.processValue(this.themes[jsonThemeName][modeName], token);
    }
  }
  processTokens(variables, jsonThemeName) {
    // Process tokens collection
    for (const token of Object.values(variables)) {
      if (isFontFamilyToken(token)) {
        if (!jsonThemeName) continue;
        if (!this.tokens[jsonThemeName]) this.tokens[jsonThemeName] = {};
        if (typeof this.tokens[jsonThemeName] !== "object")
          this.tokens[jsonThemeName] = {};
        this.tokens[jsonThemeName][`typography/${token.variableName}`] =
          this.overrides?.fontFamily?.[token.fontFamily] ?? token.fontFamily;
        this.tokens[jsonThemeName][`typography/${token.variableName}-size`] =
          `${token.fontSize.toString()}px`;
        // check if overrides.fontWeight is defined
        if (this.overrides?.fontWeight) {
          const weight = this.overrides.fontWeight.find(
            (weight) =>
              weight.alias === token.fontWeight.alias &&
              weight.fontFamily === token.fontFamily,
          );
          // check if there's a weight that matches the alias and fontFamily
          // if there is, use the value from the overrides
          // if there isn't, use the value from the token
          if (weight) {
            this.tokens[jsonThemeName][
              `typography/${token.variableName}-weight`
            ] = weight.value.toString();
          } else {
            this.tokens[jsonThemeName][
              `typography/${token.variableName}-weight`
            ] = token.fontWeight.value.toString();
          }
        } else {
          this.tokens[jsonThemeName][
            `typography/${token.variableName}-weight`
          ] = token.fontWeight.value.toString();
        }
        if (token.lineHeight.unit === "PERCENT") {
          this.tokens[jsonThemeName][
            `typography/${token.variableName}-line-height`
          ] = `${token.lineHeight.value.toString()}%`;
        } else {
          this.tokens[jsonThemeName][
            `typography/${token.variableName}-line-height`
          ] = "1.2";
        }
        this.tokens[jsonThemeName][
          `typography/${token.variableName}-letter-spacing`
        ] =
          token.letterSpacing.unit === "PIXELS"
            ? `${token.letterSpacing.value.toString()}px`
            : `${token.letterSpacing.value.toString()}%`;
        this.tokens[jsonThemeName][
          `typography/${token.variableName}-text-case`
        ] = token.textCase;
        this.tokens[jsonThemeName][
          `typography/${token.variableName}-text-decoration`
        ] = token.textDecoration;
        continue;
      }
      if (isEffectToken(token)) {
        const effectValue = [];
        token.effects.forEach((effect) => {
          const {
            color: { r, g, b, a },
            offset: { x, y },
            radius,
            spread,
          } = effect;
          effectValue.push(
            `${x.toString()}px ${y.toString()}px ${radius.toString()}px ${spread.toString()}px rgba(${r.toString()}, ${g.toString()}, ${b.toString()}, ${a.toString()})`,
          );
        });
        this.tokens[`effect/${token.variableName}`] = effectValue.join(", ");
        continue;
      }
      if (isColorOrFloatToken(token)) {
        const modeName = capitalize(token.mode)
          .replace(/[()/]/g, "-")
          .replace(/\s/g, "")
          .replace(/-$/, "");
        if (modeName !== "mode1") this.themes[modeName] = {};
        if (token.type === "color" && !this.colors.includes(token.name)) {
          this.colors.push(token.name);
        }
        if (
          token.name.startsWith("size/spacer/") &&
          !this.spacers.includes(token.name)
        ) {
          this.spacers.push(token.name);
        }
        if (
          token.name.startsWith("size/border-radius/") &&
          !this.borderRadius.includes(token.name)
        ) {
          this.borderRadius.push(token.name);
        }
        this.processTokenValue(token, modeName, jsonThemeName);
      } else {
        console.warn(
          `${JSON.stringify(token, null, 2)} could not be processed`,
        );
      }
    }
  }
}

function parseValue(value, recursicaTokens) {
  if (typeof value === "object") {
    if (value.collection === "Tokens") {
      return `${recursicaTokens}["${value.name}"]`;
    }
    if (value.collection === "Themes") {
      return `themeVars["${value.name}"]`;
    }
  } else if (!isNaN(Number(value))) {
    return `"${value}"`;
  }
  return `"${value.toString()}"`;
}
function generateTypeDefinitions(themeDef) {
  // Extract all unique theme modes from themeDef
  const allThemeModes = new Set();
  Object.values(themeDef).forEach((themeVariants) => {
    Object.keys(themeVariants).forEach((mode) => {
      allThemeModes.add(mode);
    });
  });
  // Generate the ThemeVariant interface dynamically
  const themeVariantProperties = Array.from(allThemeModes)
    .sort() // Sort for consistent output
    .map((mode) => `  ${mode}: string;`)
    .join("\n");
  return `${autoGeneratedFile()}
import { THEMES } from "./RecursicaThemes";

export interface ThemeVariant {
${themeVariantProperties}
}

// TypeScript will automatically infer this as a union of literal types
export type ThemeType = typeof THEMES[keyof typeof THEMES];

export type ThemeDictionary = Record<ThemeType, ThemeVariant>;
`;
}
function generateVanillaExtractThemes(
  tokens,
  themes,
  recursicaTokensFilename,
  { outputPath, project },
) {
  const themesContent = [];
  // Contract tokens
  const projectName =
    typeof project === "string" ? project : (project.name ?? "Recursica");
  const themeContractFilename = `Recursica${projectName}ContractTheme.css`;
  const contractThemeOutputPath =
    outputPath + "/" + `${themeContractFilename}.ts`;
  const contractTokens = {};
  const themeDef = {};
  for (const [rawThemeName, currentTheme] of Object.entries(themes)) {
    for (const [key, theme] of Object.entries(currentTheme)) {
      const currentThemeName = capitalize(rawThemeName);
      const recursicaTokens = `Recursica${projectName}Tokens`;
      const themeKey = key.replace(/-([a-z])/g, (_, letter) =>
        letter.toUpperCase(),
      );
      const themeName = `${currentThemeName}${themeKey}Theme`;
      if (!themeDef[currentThemeName]) {
        themeDef[currentThemeName] = {};
      }
      themeDef[currentThemeName][themeKey] = themeName;
      const generatedThemeContent = `${autoGeneratedFile()}
import { createTheme } from '@vanilla-extract/css';

import { themeVars } from './${themeContractFilename.replace(".ts", "")}'
import { ${recursicaTokens} } from './${recursicaTokensFilename.replace(".ts", "")}'

export const ${themeName} = createTheme(themeVars,{
  ${Object.entries(theme)
    .map(([key, value]) => {
      contractTokens[key] = null;
      return `'${key}': ${parseValue(value, recursicaTokens)}`;
    })
    .join(",\n\t")},
  ${Object.entries(tokens?.[rawThemeName] ?? {})
    .map(([key, value]) => {
      contractTokens[key] = null;
      return `'${key}': ${parseValue(value, recursicaTokens)}`;
    })
    .join(",\n\t")}
})`;
      themesContent.push({
        name: themeName,
        content: generatedThemeContent,
      });
    }
  }
  let themesFileContent = autoGeneratedFile();
  const vanillaExtractThemes = [];
  for (const theme of themesContent) {
    const themeName = `Recursica${projectName}${theme.name}`;
    const autoGeneratedThemeFilename = `${themeName}.css.ts`;
    const themeFilePath = outputPath + "/" + autoGeneratedThemeFilename;
    vanillaExtractThemes.push({
      content: theme.content,
      path: themeFilePath,
      filename: autoGeneratedThemeFilename,
    });
    // generate a theme.css.ts where we import all the themes using just 1 variables (1 export)
    themesFileContent += `export { ${theme.name} } from './${autoGeneratedThemeFilename.replace(".ts", "")}';\n`;
    themesFileContent += `import { ${theme.name} } from './${autoGeneratedThemeFilename.replace(".ts", "")}';\n`;
  }
  themesFileContent += `\nexport const Themes = {
  ${Object.entries(themeDef)
    .map(
      ([key, value]) => `'${key}': {
    ${Object.entries(value)
      .map(([key, value]) => `'${key}': ${value}`)
      .join(",\n\t\t")}`,
    )
    .join("\n\t},\n\t")}
  }
}`;
  // create the themes.ts file
  const availableThemesContent = `${autoGeneratedFile()}
export const AvailableThemes = [${themesContent.map((theme) => `"${theme.name}"`).join(", ")}] as const;
export type AvailableThemesType = (typeof AvailableThemes)[number];
`;
  const availableThemesPath = outputPath + "/types.ts";
  const themeContractContent = `${autoGeneratedFile()}
import { createThemeContract } from '@vanilla-extract/css';

export const themeVars = createThemeContract(${JSON.stringify(contractTokens, null, 2)});
`;
  const themesFilename = `Recursica${projectName}Themes.css.ts`;
  const themesFilePath = outputPath + "/" + themesFilename;
  // Generate type definitions in types.d.ts
  const typeDefinitionsContent = generateTypeDefinitions(themeDef);
  const typesPath = outputPath + "/types.d.ts";
  return {
    typeDefinitions: {
      content: typeDefinitionsContent,
      path: typesPath,
      filename: "types.d.ts",
    },
    themesFileContent: {
      content: themesFileContent,
      path: themesFilePath,
      filename: themesFilename,
    },
    availableThemes: {
      content: availableThemesContent,
      path: availableThemesPath,
      filename: "types.ts",
    },
    vanillaExtractThemes,
    themeContract: {
      content: themeContractContent,
      path: contractThemeOutputPath,
      filename: themeContractFilename,
    },
    contractTokens,
  };
}

function generateRecursicaTokens(baseTokens, { outputPath, project }) {
  const projectName =
    typeof project === "string" ? project : (project.name ?? "Recursica");
  const recursicaTokensFilename = `Recursica${projectName}Tokens.ts`;
  const recursicaTokensPath = outputPath + "/" + recursicaTokensFilename;
  const recursicaTokensContent = `${autoGeneratedFile()}
export const Recursica${projectName}Tokens = {
  ${Object.entries(baseTokens)
    .filter(([_, value]) => typeof value === "string")
    .map(([key, value]) => `"${key}": "${value}"`)
    .join(",\n  ")}
};
`;
  return {
    content: recursicaTokensContent,
    path: recursicaTokensPath,
    filename: recursicaTokensFilename,
  };
}

function generateUiKit(
  uiKit,
  { recursicaTokensFilename, themeContractFilename },
  { outputPath, project },
) {
  const projectName =
    typeof project === "string" ? project : (project.name ?? "Recursica");
  const uiKitFilename = `Recursica${projectName}UiKit.ts`;
  const uiKitPath = outputPath + "/" + uiKitFilename;
  const recursicaTokens = `Recursica${projectName}Tokens`;
  const uiKitContent = `${autoGeneratedFile()}
import { themeVars } from './${themeContractFilename.replace(".ts", "")}'
import { ${recursicaTokens} } from './${recursicaTokensFilename.replace(".ts", "")}'

export const uiKit = {
  ${Object.entries(uiKit)
    .map(([key, value]) => `'${key}': ${parseValue(value, recursicaTokens)}`)
    .join(",\n\t")}\n\t}`;
  return {
    content: uiKitContent,
    path: uiKitPath,
    filename: uiKitFilename,
  };
}

function parseKey(key) {
  return key.replaceAll("/", "-");
}
function generateMantineTheme({
  mantineThemeOverride,
  tokens,
  breakpoints,
  contractTokens: { tokens: contractTokens, filename: contractFilename },
  exportingProps: { outputPath, project, rootPath },
}) {
  const themeTokens = {
    colors: {},
    radius: {},
    fontSizes: {},
    primaryColor: mantineThemeOverride?.["1-scale"],
    white: mantineThemeOverride?.background,
  };
  for (const [key, value] of Object.entries(tokens)) {
    if (typeof value === "object") continue;
    if (key.includes("border-radius")) {
      themeTokens.radius[parseKey(key)] = value;
    }
    if (key.includes("font/size")) {
      themeTokens.fontSizes[parseKey(key)] = `"${value}"`;
    }
  }
  for (const [key] of Object.entries(contractTokens)) {
    if (key.includes("color/") || key.includes("color-on/")) {
      themeTokens.colors[parseKey(key)] = `themeVars['${key}']`;
    }
    if (/font\/(\w+)\/size/.test(key)) {
      themeTokens.fontSizes[parseKey(key)] = `themeVars['${key}']`;
    }
  }
  const postCssFilename = "postcss.config.cjs";
  let postCssContent = `${autoGeneratedFile()}\n`;
  postCssContent += `module.exports = {
  plugins: {
    'postcss-preset-mantine': {},
    'postcss-simple-vars': {
      variables: {`;
  for (const [key, value] of Object.entries(breakpoints)) {
    postCssContent += `\n\t\t\t\t'mantine-breakpoint-${key}': '${value}',`;
  }
  postCssContent += `
      }
    }
  }
}`;
  const postCssFileContent = {
    content: postCssContent,
    path: rootPath ? rootPath + "/" + postCssFilename : postCssFilename,
    filename: postCssFilename,
  };
  const fileContent = `${autoGeneratedFile()}
import { colorsTuple, createTheme } from '@mantine/core'
import { themeVars } from './${contractFilename.replace(".ts", "")}'

export const mantineTheme = createTheme({
  ${themeTokens.primaryColor ? `primaryColor: ${themeTokens.primaryColor},` : ""}
  ${themeTokens.white ? `white: ${themeTokens.white},` : ""}
  breakpoints: {
    ${Object.entries(breakpoints)
      .map(([key, value]) => `'${key}': '${value}'`)
      .join(",\n\t\t")}
  },
  colors: {
    ${Object.entries(themeTokens.colors)
      .map(([key, value]) => `"${key}": colorsTuple(${value})`)
      .join(",\n\t\t")}
  },
  radius: {
    ${Object.entries(themeTokens.radius)
      .map(([key, value]) => `"${key}": "${value}"`)
      .join(",\n\t\t")}
  },
  fontSizes: {
    ${Object.entries(themeTokens.fontSizes)
      .map(([key, value]) => `"${key}": ${value}`)
      .join(",\n\t\t")}
  }
})`;
  const projectName =
    typeof project === "string" ? project : (project.name ?? "Recursica");
  const filename = `Recursica${projectName}MantineTheme.ts`;
  const mantineThemeFileContent = {
    content: fileContent,
    path: outputPath + "/" + filename,
    filename,
  };
  return { mantineTheme: mantineThemeFileContent, postCss: postCssFileContent };
}

function createRecursicaObject(project, outputPath) {
  const projectName =
    typeof project === "string" ? project : (project.name ?? "Recursica");
  const tokens = `Recursica${projectName}Tokens`;
  const contract = `Recursica${projectName}ContractTheme`;
  const uiKit = `Recursica${projectName}UiKit`;
  const recursicaObjectContent = `${autoGeneratedFile()}
import { ${tokens} } from './${tokens}';
import { themeVars } from './${contract}.css';
import { uiKit } from './${uiKit}';

export const recursica = {
  ...uiKit,
  ...themeVars,
  ...${tokens},
}
`;
  return {
    content: recursicaObjectContent,
    path: outputPath + "/Recursica.ts",
    filename: "Recursica.ts",
  };
}

function generateColorsType(colorTokens, outputPath) {
  const colorsType = `${autoGeneratedFile()}
export type RecursicaColors = \n\t"${colorTokens.join('" |\n\t"')}";\n`;
  return {
    content: colorsType,
    path: `${outputPath}/RecursicaColorsType.ts`,
    filename: "RecursicaColorsType.ts",
  };
}

function generateIcons(icons, srcPath, config) {
  let iconsPath;
  if (!config?.output) {
    iconsPath = srcPath + "/components" + "/Icons";
  } else {
    iconsPath = srcPath + "/" + config.output;
  }
  const svgPath = iconsPath + "/Svg";
  const exportedIcons = [];
  // Generate svg files
  for (const [rawIconName, iconPath] of Object.entries(icons)) {
    const [iconName, variant] = rawIconName.split("[");
    let cleanIconName = iconName.replaceAll("-", "_");
    // check if the iconName is in the names array, if not, skip
    if (!config?.include?.names?.includes(cleanIconName)) {
      continue;
    }
    // detect if the iconName starts with a number, if so, add an underscore to the beginning
    if (cleanIconName.match(/^\d/)) {
      cleanIconName = `_${cleanIconName}`;
    }
    const cleanVariant = variant.replace("]", "").replace("Style=", "");
    const codedVariant = cleanVariant.replaceAll(" ", "_");
    // check if the codedVariant is in the variants array, if not, skip
    if (!config?.include?.variants?.includes(codedVariant)) {
      continue;
    }
    const finalIconName = `${cleanIconName}_${codedVariant}`;
    exportedIcons.push({
      content: iconPath
        .replaceAll('fill="black"', "")
        .replaceAll('fill="none"', ""),
      path: `${svgPath}/${finalIconName}.svg`,
      filename: `${finalIconName}`,
    });
  }
  // Generate icon exports file
  const exportsPath = iconsPath + "/icon_exports.ts";
  let exportsContent = `${autoGeneratedFile()}
/// <reference types="vite-plugin-svgr/client" />\n`;
  for (const icon of exportedIcons) {
    exportsContent += `import ${icon.filename} from './Svg/${icon.filename}.svg?react';\n`;
    exportsContent += `export { ${icon.filename} };\n`;
  }
  // Generate icon map file
  const mapPath = iconsPath + "/icon_resource_map.ts";
  let mapContent = `${autoGeneratedFile()}\nimport * as IconExports from './icon_exports';\n\n`;
  mapContent += "export const IconResourceMap = {";
  mapContent += exportedIcons
    .map((icon) => `\n\t'${icon.filename}': IconExports.${icon.filename},`)
    .join("");
  mapContent += "\n};\n";
  return {
    exportedIcons,
    iconExports: {
      content: exportsContent,
      path: exportsPath,
      filename: "icon_exports.ts",
    },
    iconResourceMap: {
      content: mapContent,
      path: mapPath,
      filename: "icon_resource_map.ts",
    },
  };
}

function generateSpacersType(spacerTokens, outputPath) {
  const spacersType = `${autoGeneratedFile()}
export type RecursicaSpacersType = \n\t"${spacerTokens.join('" |\n\t"')}";\n`;
  return {
    content: spacersType,
    path: `${outputPath}/RecursicaSpacersType.ts`,
    filename: "RecursicaSpacersType.ts",
  };
}

function generateBorderRadiusType(borderRadius, outputPath) {
  const borderRadiusTypeContent = `${autoGeneratedFile()}
export type RecursicaBorderRadiusType = ${borderRadius
    .map((key) => `'${key}'`)
    .join(" | ")};
`;
  return {
    content: borderRadiusTypeContent,
    path: `${outputPath}/RecursicaBorderRadiusType.ts`,
    filename: "RecursicaBorderRadiusType.ts",
  };
}

/**
 * Generates the RecursicaThemes.ts file that contains the THEMES constant
 * based on the theme dictionary
 */
function generateRecursicaThemes({ outputPath, themes }) {
  const themeDef = {};
  // Build themeDef object similar to generateVanillaExtractThemes
  for (const [rawThemeName, currentTheme] of Object.entries(themes)) {
    for (const [key] of Object.entries(currentTheme)) {
      const currentThemeName = capitalize(rawThemeName);
      const themeKey = key.replace(/-([a-z])/g, (_, letter) =>
        letter.toUpperCase(),
      );
      themeDef[currentThemeName] ?? (themeDef[currentThemeName] = {});
      themeDef[currentThemeName][themeKey] = currentThemeName;
    }
  }
  const content = `/* prettier-ignore */
/* eslint-disable */
/* tslint:disable */
/*
Auto-generated by Recursica.
Do NOT edit these files directly

For more information about Recursica, go to https://recursica.com
*/

// Auto-generated THEMES constant from ThemeType
export const THEMES = {
${Object.entries(themeDef)
  .map(([key]) => `  ${key}: '${key}'`)
  .join(",\n")}
} as const;
`;
  return {
    content,
    path: outputPath + "/RecursicaThemes.ts",
    filename: "RecursicaThemes.ts",
  };
}

function generatePrettierignore() {
  return {
    filename: ".prettierignore",
    path: ".prettierignore",
    content: `recursica/
recursica.json
recursica-bundle.json
recursica-icons.json`,
  };
}

function runAdapter({
  rootPath,
  overrides,
  srcPath,
  project,
  icons,
  iconsConfig,
  processTokens,
}) {
  const outputPath = srcPath + "/recursica";
  const recursicaTokens = generateRecursicaTokens(processTokens.tokens, {
    outputPath,
    project,
  });
  const vanillaExtractThemes = generateVanillaExtractThemes(
    processTokens.tokens,
    processTokens.themes,
    recursicaTokens.filename,
    {
      outputPath,
      project,
    },
  );
  const mantineTheme = generateMantineTheme({
    mantineThemeOverride: overrides?.mantineTheme,
    tokens: processTokens.tokens,
    breakpoints: processTokens.breakpoints,
    contractTokens: {
      tokens: vanillaExtractThemes.contractTokens,
      filename: vanillaExtractThemes.themeContract.filename,
    },
    exportingProps: {
      outputPath,
      project,
      rootPath,
    },
  });
  const uiKitObject = generateUiKit(
    processTokens.uiKit,
    {
      recursicaTokensFilename: recursicaTokens.filename,
      themeContractFilename: vanillaExtractThemes.themeContract.filename,
    },
    { outputPath, project },
  );
  const recursicaObject = createRecursicaObject(project, outputPath);
  const colorsType = generateColorsType(processTokens.colors, outputPath);
  const spacersType = generateSpacersType(processTokens.spacers, outputPath);
  const borderRadiusType = generateBorderRadiusType(
    processTokens.borderRadius,
    outputPath,
  );
  let iconsObject;
  if (icons) {
    iconsObject = generateIcons(icons, srcPath, iconsConfig);
  }
  const recursicaThemes = generateRecursicaThemes({
    outputPath,
    themes: processTokens.themes,
  });
  const prettierignore = generatePrettierignore();
  const fileContents = {
    recursicaTokens,
    vanillaExtractThemes,
    mantineTheme,
    uiKitObject,
    recursicaObject,
    colorsType,
    spacersType,
    borderRadiusType,
    iconsObject,
    recursicaThemes,
    prettierignore,
  };
  return fileContents;
}

/**
 * Processes JSON content and creates ProcessTokens instance
 * This is shared logic between CLI and WebWorker
 */
function processJsonContent(jsonFileContent, { project, overrides }) {
  const jsonContent = JSON.parse(jsonFileContent);
  const jsonProjectId = jsonContent.projectId;
  if (!jsonProjectId) {
    throw new Error("project-id is required in the json file");
  }
  if (
    jsonProjectId.toLowerCase() !==
    (typeof project === "string"
      ? project.toLowerCase()
      : project.name?.toLowerCase())
  ) {
    throw new Error("project-id does not match the project in the config file");
  }
  const processTokens = new ProcessTokens(overrides);
  processTokens.processTokens(jsonContent.tokens);
  for (const theme of Object.keys(jsonContent.themes)) {
    processTokens.processTokens(jsonContent.themes[theme], theme);
  }
  processTokens.processTokens(jsonContent.uiKit);
  return processTokens;
}
/**
 * Processes icons JSON content and returns icons object
 * This is shared logic between CLI and WebWorker
 */
function processIcons(iconsJsonContent) {
  const icons = {};
  const iconsJsonParsed = JSON.parse(iconsJsonContent);
  for (const [iconName, iconPath] of Object.entries(iconsJsonParsed)) {
    icons[iconName] = iconPath;
  }
  return icons;
}
/**
 * Core adapter processing logic shared between CLI and WebWorker
 * This function handles the main processing workflow
 */
function processAdapter({
  rootPath,
  bundledJsonContent,
  project,
  overrides,
  srcPath,
  iconsJsonContent,
  iconsConfig,
}) {
  let icons = {};
  // Process icons if provided
  if (iconsJsonContent) {
    icons = processIcons(iconsJsonContent);
  }
  if (!bundledJsonContent) {
    throw new Error("bundledJson content not found");
  }
  // Process the main JSON content
  const processTokens = processJsonContent(bundledJsonContent, {
    project,
    overrides,
  });
  // Run the adapter
  const files = runAdapter({
    rootPath,
    overrides,
    srcPath,
    icons,
    processTokens,
    project,
    iconsConfig,
  });
  return files;
}

// 1. Listen for a message from the main application thread
// You can use self.addEventListener or the shorter self.onmessage
self.onmessage = (event) => {
  // Run the script
  const params = event.data;
  try {
    const { bundledJson, srcPath, project, overrides, iconsConfig, rootPath } =
      params;
    if (!bundledJson) throw new Error("bundledJson not found");
    // Use shared processing logic
    const files = processAdapter({
      bundledJsonContent: params.bundledJson,
      project,
      overrides,
      srcPath,
      rootPath,
      iconsJsonContent: params.iconsJson,
      iconsConfig,
    });
    // 3. Send the response back to the main thread
    console.log("...Worker sending response back:", files);
    self.postMessage(files);
  } catch (error) {
    console.error("Error generating theme:", error);
  }
};
